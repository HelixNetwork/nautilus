diff a/src/desktop/src/libs/seed/keychain.js b/src/desktop/src/libs/seed/keychain.js	(rejected hunks)
@@ -2,4 +2,4 @@
-import { ACC_MAIN, sha256, encrypt, decrypt } from "libs/crypto";
-import { ALIAS_REALM } from "libs/realm";
-import { bitsToChars, indexToBit } from "libs/hlx/converter";
-import { prepareTransfers as prepareTransfer } from "libs/hlx/extendedApi";
+import { ACC_MAIN, sha256, encrypt, decrypt } from 'libs/crypto';
+import { ALIAS_REALM } from 'libs/realm';
+import { bitsToChars, indexToBit } from 'libs/hlx/converter';
+import { prepareTransfers as prepareTransfer } from 'libs/hlx/extendedApi';
@@ -7 +7 @@ import { prepareTransfers as prepareTransfer } from "libs/hlx/extendedApi";
-import SeedStoreCore from "./seedStoreCore";
+import SeedStoreCore from './seedStoreCore';
@@ -9 +9 @@ import SeedStoreCore from "./seedStoreCore";
-const ACC_PREFIX = "account";
+const ACC_PREFIX = 'account';
@@ -12,65 +12,17 @@ class Keychain extends SeedStoreCore {
-  /**
-   * Init the vault
-   * @param {array} key - Account decryption key
-   * @param {string} accountId - Account identifier
-   */
-  constructor(key, accountId) {
-    super();
-  
-    
-    return (async () => {
-        this.key = key.slice(0);
-      
-      if (accountId) {
-        this.accountId = await sha256(`${ACC_PREFIX}-${accountId}`);
-      }
-
-      return this;
-    })();
-  }
-
-  /**
-   * If seed is available in plain form
-   * @returns {boolean}
-   */
-  static get isSeedAvailable() {
-    return true;
-  }
-
-  /**
-   * If attaching a message to transactions is available
-   * @returns {boolean}
-   */
-  static get isMessageAvailable() {
-    return true;
-  }
-
-  /**
-   * Return max supported input count
-   * @returns {number} - 0 for no limit
-   */
-  getMaxInputs = () => {
-    return 0;
-  };
-
-  /**
-   * Create new account
-   * @param {string} accountId - Account identifier
-   * @param {array} seed - Byte array seed
-   * @returns {promise} - Resolves to a success boolean
-   */
-  addAccount = async (accountId, seed) => {
-    this.accountId = await sha256(`${ACC_PREFIX}-${accountId}`);
-
-    const vault = await encrypt(seed, this.key);
-    await Electron.setKeychain(this.accountId, vault);
-
-    return true;
-  };
-
-  /**
-   * Remove account
-   */
-  removeAccount = async () => {
-    if (!this.accountId) {
-      throw new Error("Account not selected");
+    /**
+     * Init the vault
+     * @param {array} key - Account decryption key
+     * @param {string} accountId - Account identifier
+     */
+    constructor(key, accountId) {
+        super();
+
+        return (async () => {
+            this.key = key.slice(0);
+
+            if (accountId) {
+                this.accountId = await sha256(`${ACC_PREFIX}-${accountId}`);
+            }
+
+            return this;
+        })();
@@ -79 +31,7 @@ class Keychain extends SeedStoreCore {
-    const isRemoved = await Electron.removeKeychain(this.accountId);
+    /**
+     * If seed is available in plain form
+     * @returns {boolean}
+     */
+    static get isSeedAvailable() {
+        return true;
+    }
@@ -81,2 +39,6 @@ class Keychain extends SeedStoreCore {
-    if (!isRemoved) {
-      throw new Error("Incorrect seed name");
+    /**
+     * If attaching a message to transactions is available
+     * @returns {boolean}
+     */
+    static get isMessageAvailable() {
+        return true;
@@ -85,2 +47,16 @@ class Keychain extends SeedStoreCore {
-    return true;
-  };
+    /**
+     * Return max supported input count
+     * @returns {number} - 0 for no limit
+     */
+    getMaxInputs = () => {
+        return 0;
+    };
+
+    /**
+     * Create new account
+     * @param {string} accountId - Account identifier
+     * @param {array} seed - Byte array seed
+     * @returns {promise} - Resolves to a success boolean
+     */
+    addAccount = async (accountId, seed) => {
+        this.accountId = await sha256(`${ACC_PREFIX}-${accountId}`);
@@ -88,7 +64,2 @@ class Keychain extends SeedStoreCore {
-  /**
-   * Rename account
-   * @param {string} accountName - New account name
-   * @returns {boolean} Seed renamed success state
-   */
-  renameAccount = async accountName => {
-    const newID = await sha256(`${ACC_PREFIX}-${accountName}`);
+        const vault = await encrypt(seed, this.key);
+        await Electron.setKeychain(this.accountId, vault);
@@ -96 +67,2 @@ class Keychain extends SeedStoreCore {
-    const vault = await Electron.readKeychain(this.accountId);
+        return true;
+    };
@@ -98,3 +70,7 @@ class Keychain extends SeedStoreCore {
-    if (!vault) {
-      throw new Error("Incorrect seed name");
-    }
+    /**
+     * Remove account
+     */
+    removeAccount = async () => {
+        if (!this.accountId) {
+            throw new Error('Account not selected');
+        }
@@ -102 +78 @@ class Keychain extends SeedStoreCore {
-    await decrypt(vault, this.key);
+        const isRemoved = await Electron.removeKeychain(this.accountId);
@@ -104,2 +80,3 @@ class Keychain extends SeedStoreCore {
-    await Electron.removeKeychain(this.accountId);
-    await Electron.setKeychain(newID, vault);
+        if (!isRemoved) {
+            throw new Error('Incorrect seed name');
+        }
@@ -107 +84,2 @@ class Keychain extends SeedStoreCore {
-    this.accountId = newID;
+        return true;
+    };
@@ -109,2 +87,7 @@ class Keychain extends SeedStoreCore {
-    return true;
-  };
+    /**
+     * Rename account
+     * @param {string} accountName - New account name
+     * @returns {boolean} Seed renamed success state
+     */
+    renameAccount = async (accountName) => {
+        const newID = await sha256(`${ACC_PREFIX}-${accountName}`);
@@ -112,8 +95 @@ class Keychain extends SeedStoreCore {
-  /**
-   * Update vault password
-   * @param {array} key - Current encryption key
-   * @param {array} keyNew - New encryption key
-   * @returns {boolean} Password updated success state
-   */
-  static updatePassword = async (key, keyNew) => {
-    const vault = await Electron.listKeychain();
+        const vault = await Electron.readKeychain(this.accountId);
@@ -121,3 +97,3 @@ class Keychain extends SeedStoreCore {
-    if (!vault) {
-      throw new Error("Local storage not available");
-    }
+        if (!vault) {
+            throw new Error('Incorrect seed name');
+        }
@@ -125 +101 @@ class Keychain extends SeedStoreCore {
-    const accounts = Object.keys(vault);
+        await decrypt(vault, this.key);
@@ -127,3 +103,2 @@ class Keychain extends SeedStoreCore {
-    if (!accounts.length) {
-      return true;
-    }
+        await Electron.removeKeychain(this.accountId);
+        await Electron.setKeychain(newID, vault);
@@ -131,2 +106 @@ class Keychain extends SeedStoreCore {
-    for (let i = 0; i < accounts.length; i++) {
-      const account = vault[i];
+        this.accountId = newID;
@@ -134,6 +108,2 @@ class Keychain extends SeedStoreCore {
-      if (
-        account.account === `${ACC_MAIN}-salt` ||
-        account.account === ALIAS_REALM
-      ) {
-        continue;
-      }
+        return true;
+    };
@@ -141,2 +111,8 @@ class Keychain extends SeedStoreCore {
-      const decryptedVault = await decrypt(account.password, key);
-      const encryptedVault = await encrypt(decryptedVault, keyNew);
+    /**
+     * Update vault password
+     * @param {array} key - Current encryption key
+     * @param {array} keyNew - New encryption key
+     * @returns {boolean} Password updated success state
+     */
+    static updatePassword = async (key, keyNew) => {
+        const vault = await Electron.listKeychain();
@@ -144,2 +120,3 @@ class Keychain extends SeedStoreCore {
-      await Electron.setKeychain(account.account, encryptedVault);
-    }
+        if (!vault) {
+            throw new Error('Local storage not available');
+        }
@@ -147,22 +124 @@ class Keychain extends SeedStoreCore {
-    return true;
-  };
-
-  /**
-   * Generate address
-   * @param {object} options - Address generation options
-   *   @property {number} index - Address index
-   *   @property {number} security - Address generation security level - 1,2 or 3
-   *   @property {number} total - Address count to return
-   * @returns {promise}
-   */
-  generateAddress = async options => {
-    const seed = await this.getSeed(true);
-    const addresses = await Electron.genFn(
-      seed,
-      options.index,
-      options.security,
-      options.total
-    );
-    for (let i = 0; i < seed.length * 8; i++) {
-      seed[i % seed.length] = 0;
-    }
+        const accounts = Object.keys(vault);
@@ -170,41 +126,3 @@ class Keychain extends SeedStoreCore {
-    Electron.garbageCollect();
-
-    return addresses;
-  };
-
-  /**
-   * Placeholder for Nautilus Wallet compatibillity
-   * @returns {boolean}
-   */
-  validateAddress = () => {
-    return true;
-  };
-
-  /**
-   * Prepare transfers
-   */
-  prepareTransfers = async (transfers, options = null) => {
-    let seed = await this.getSeed(true);
-    seed = bitsToChars(seed);
-    // transfers.map(obj => obj.tag = "abcdef")
-    const transfer = await prepareTransfer()(seed, transfers, options);
-    // for (let i = 0; i < seed.length * 3; i++) {
-    //     seed[i % seed.length] = 0;
-    // }
-
-    Electron.garbageCollect();
-
-    return transfer;
-  };
-
-  /**
-   * Get seed from keychain
-   * @param {boolean} rawBits - Should return raw txBits
-   * @returns {array} Decrypted seed
-   */
-  getSeed = async rawBits => {
-    const vault = await Electron.readKeychain(this.accountId);
-
-    if (!vault) {
-      throw new Error("Incorrect seed name");
-    }
+        if (!accounts.length) {
+            return true;
+        }
@@ -212,42 +130,11 @@ class Keychain extends SeedStoreCore {
-    const decryptedVault = await decrypt(vault, this.key);
-    if (rawBits) {
-      let txBits = [];
-      for (let i = 0; i < decryptedVault.length; i++) {
-        txBits = txBits.concat(indexToBit(decryptedVault[i]));
-      }
-      return txBits;
-    }
-    return decryptedVault;
-  };
-
-  /**
-   * Unique seed check
-   * @param {array} Seed - Seed to check
-   * @returns {boolean} If Seed is unique
-   */
-  isUniqueSeed = async seed => {
-    const vault = await Electron.listKeychain();
-    if (!vault) {
-      throw new Error("Local storage not available");
-    }
-    try {
-      const accounts = vault.filter(
-        acc =>
-          acc.account !== ACC_MAIN &&
-          acc.account !== `${ACC_MAIN}-salt` &&
-          acc.account !== ALIAS_REALM
-      );
-
-      for (let i = 0; i < accounts.length; i++) {
-        const account = accounts[i];
-
-        const vaultSeed = await decrypt(account.password, this.key);
-
-        if (
-          vaultSeed &&
-          vaultSeed.length === seed.length &&
-          seed.every((v, x) => {
-            return v % 27 === vaultSeed[x] % 27;
-          })
-        ) {
-          return false;
+        for (let i = 0; i < accounts.length; i++) {
+            const account = vault[i];
+
+            if (account.account === `${ACC_MAIN}-salt` || account.account === ALIAS_REALM) {
+                continue;
+            }
+
+            const decryptedVault = await decrypt(account.password, key);
+            const encryptedVault = await encrypt(decryptedVault, keyNew);
+
+            await Electron.setKeychain(account.account, encryptedVault);
@@ -255 +141,0 @@ class Keychain extends SeedStoreCore {
-      }
@@ -257,15 +143,117 @@ class Keychain extends SeedStoreCore {
-      return true;
-    } catch (err) {
-      throw err;
-    }
-  };
-
-  /**
-   * Destroy the vault
-   */
-  destroy = () => {
-    for (let i = 0; i < this.key.length * 3; i++) {
-      this.key[i % this.key.length] = 0;
-    }
-    delete this.key;
-  };
+        return true;
+    };
+
+    /**
+     * Generate address
+     * @param {object} options - Address generation options
+     *   @property {number} index - Address index
+     *   @property {number} security - Address generation security level - 1,2 or 3
+     *   @property {number} total - Address count to return
+     * @returns {promise}
+     */
+    generateAddress = async (options) => {
+        const seed = await this.getSeed(true);
+        const addresses = await Electron.genFn(seed, options.index, options.security, options.total);
+        for (let i = 0; i < seed.length * 8; i++) {
+            seed[i % seed.length] = 0;
+        }
+
+        Electron.garbageCollect();
+
+        return addresses;
+    };
+
+    /**
+     * Placeholder for Nautilus Wallet compatibillity
+     * @returns {boolean}
+     */
+    validateAddress = () => {
+        return true;
+    };
+
+    /**
+     * Prepare transfers
+     */
+    prepareTransfers = async (transfers, options = null) => {
+        let seed = await this.getSeed(true);
+        seed = bitsToChars(seed);
+        // transfers.map(obj => obj.tag = "abcdef")
+        const transfer = await prepareTransfer()(seed, transfers, options);
+        // for (let i = 0; i < seed.length * 3; i++) {
+        //     seed[i % seed.length] = 0;
+        // }
+
+        Electron.garbageCollect();
+
+        return transfer;
+    };
+
+    /**
+     * Get seed from keychain
+     * @param {boolean} rawBits - Should return raw txBits
+     * @returns {array} Decrypted seed
+     */
+    getSeed = async (rawBits) => {
+        const vault = await Electron.readKeychain(this.accountId);
+
+        if (!vault) {
+            throw new Error('Incorrect seed name');
+        }
+
+        const decryptedVault = await decrypt(vault, this.key);
+        if (rawBits) {
+            let txBits = [];
+            for (let i = 0; i < decryptedVault.length; i++) {
+                txBits = txBits.concat(indexToBit(decryptedVault[i]));
+            }
+            return txBits;
+        }
+        return decryptedVault;
+    };
+
+    /**
+     * Unique seed check
+     * @param {array} Seed - Seed to check
+     * @returns {boolean} If Seed is unique
+     */
+    isUniqueSeed = async (seed) => {
+        const vault = await Electron.listKeychain();
+        if (!vault) {
+            throw new Error('Local storage not available');
+        }
+        try {
+            const accounts = vault.filter(
+                (acc) => acc.account !== ACC_MAIN && acc.account !== `${ACC_MAIN}-salt` && acc.account !== ALIAS_REALM,
+            );
+
+            for (let i = 0; i < accounts.length; i++) {
+                const account = accounts[i];
+
+                const vaultSeed = await decrypt(account.password, this.key);
+
+                if (
+                    vaultSeed &&
+                    vaultSeed.length === seed.length &&
+                    seed.every((v, x) => {
+                        return v % 27 === vaultSeed[x] % 27;
+                    })
+                ) {
+                    return false;
+                }
+            }
+
+            return true;
+        } catch (err) {
+            throw err;
+        }
+    };
+
+    /**
+     * Destroy the vault
+     */
+    destroy = () => {
+        for (let i = 0; i < this.key.length * 3; i++) {
+            this.key[i % this.key.length] = 0;
+        }
+        delete this.key;
+    };
